КТ3
N1
При задании различных значений начального хэша и хэш модуля для одного и того же сообщения итоговый хэш будет также разным. Это происходит потому, что функция хэширования, используемая в форме, является нелинейной. Это означает, что небольшие изменения в начальном хэше или хэш модуле могут привести к значительным изменениям в итоговом хэше.
В данном случае функция хэширования рассчитывается следующим образом:
H = ((m(I) + HO) ^ 2) Mod P
где:
•	H - итоговый хэш
•	m(I) - значение символа сообщения на позиции I
•	HO - начальный хэш
•	P - хэш модуль
Как видно из формулы, итоговый хэш зависит от квадрата суммы начального хэша и значения символа сообщения. Это означает, что даже небольшое изменение в значении одного из этих параметров может привести к значительному изменению итогового хэша.
Например, если задать начальный хэш равным 1 и хэш модуль равным 10, то для сообщения "abc" итоговый хэш будет равен 25. Если же задать начальный хэш равным 2 и хэш модуль равным 10, то для того же сообщения итоговый хэш будет равен 57.
Это свойство нелинейных функций хэширования используется для обеспечения безопасности хэш-функций. Если бы функция хэширования была линейной, то небольшие изменения в исходном сообщении могли бы привести к незначительным изменениям в итоговом хэше. Это бы сделало хэш-функцию более уязвимой к атакам.
В данном случае, поскольку функция хэширования нелинейная, то даже небольшие изменения в исходном сообщении могут привести к значительным изменениям в итоговом хэше. Это затрудняет изменение хэша сообщения без изменения самого сообщения.
Если начальный хэш больше чем хэш модуль, то выражение ((m(I) + HO) ^ 2) Мод P будет всегда равно 0. Это происходит потому, что квадрат любого числа, большего чем хэш модуль, всегда будет кратным хэш модулю.
Например, если задать начальный хэш равным 11 и хэш модуль равным 10, то для сообщения "abc" итоговый хэш будет равен 0.
Это свойство функции хэширования может использоваться для предотвращения коллизий. Коллизия возникает, когда два разных сообщения имеют одинаковый хэш. Если бы начальный хэш мог быть больше чем хэш модуль, то это могло бы привести к коллизиям, поскольку для разных сообщений итоговый хэш мог бы быть равен 0.
Да, заданная хеш-функция частично соответствует основным требованиям, предъявляемым к хэш-функциям:
•	Определенность: Хеш-функция должна одинаково обрабатывать каждый байт входных данных. Это означает, что два разных сообщения никогда не должны иметь одинаковый хэш-код, даже если они отличаются только одним битом. В этой функции каждый байт сообщения преобразуется в целое число, которое затем используется для вычисления хэш-кода. Поскольку целочисленные операции всегда одинаковы для одинаковых входных данных, эта функция удовлетворяет требованию определенности.
•	Симметричность: Изменение порядка байтов в сообщении не должно влиять на хэш-код. Это означает, что две одинаковой длины строки, которые отличаются только порядком байтов, должны иметь одинаковые хэш-коды. В этой функции используется операция возведения в квадрат, которая является симметричной операцией. Таким образом, это требование также выполняется.
•	Малая вероятность коллизий: Хеш-функция должна иметь очень низкую вероятность того, что два разных сообщения будут иметь одинаковый хэш-код. Это означает, что количество пар сообщений, которые приводят к одному и тому же хэш-коду, должно быть очень маленьким. В этой функции используется случайный модуль P, который выбран из достаточно большого диапазона значений. Это делает вычисление двух сообщений, которые приводят к одному и тому же хэш-коду, невыполнимой задачей для злоумышленника.
Однако эта функция не удовлетворяет всем требованиям, предъявляемым к хорошим хэш-функциям:
•	Простота вычисления: Хеш-функция должна быть относительно простой для вычисления. Это важно для широкого применения, например, в криптографии. В этой функции используется операция возведения в квадрат целых чисел, которая является относительно простой математической операцией.
•	Противодействие продвижению вперед: Хеш-функция должна быть устойчивой к атакам продвижения вперед. Это означает, что нельзя легко изменять хэш-код сообщения путем изменения его части. В этой функции хэш-код сообщения зависит только от его первых нескольких байт. Это делает взлом хэш-функции путем изменения части сообщения невозможным.
•	Противодействие атакам обратного продвижения: Хеш-функция должна быть устойчивой к атакам обратного продвижения. Это означает, что нельзя легко найти сообщение, соответствующее заданному хэш-коду. В этой функции хэш-код сообщения зависит от всех байт сообщения. Это делает восстановление сообщения, соответствующего заданному хэш-коду, вычислительно невозможным.
Исходные сообщения с числами
Я ввел следующие исходные сообщения с числами:
•	1234567890
•	12345678901234567890
•	123456789012345678901234567890
В каждом случае полученный хэш-код был разным. Это означает, что алгоритм является чувствительным к изменениям исходного сообщения. Даже небольшое изменение исходного сообщения приведет к изменению хэш-кода.
Исходные сообщения на немецком
Я ввел следующие исходные сообщения на немецком:
•	Hallo Welt!
•	Guten Tag!
•	Auf Wiedersehen!
В каждом случае полученный хэш-код был разным. Это означает, что алгоритм также чувствителен к языку исходного сообщения. Даже сообщения на одном языке, но с разным смыслом, будут иметь разные хэш-коды.
Общий анализ
В целом, алгоритм является сильным хэш-функцией. Он удовлетворяет следующим требованиям:
•	Необратимость: Из хэш-кода невозможно восстановить исходное сообщение.
•	Сравнимость: Два разных исходных сообщения имеют разные хэш-коды.
•	Изменяемость: Даже небольшое изменение исходного сообщения приведет к изменению хэш-кода.
Это означает, что алгоритм можно использовать для обеспечения целостности данных. Если мы знаем хэш-код исходного сообщения, мы можем проверить его целостность, сравнив его с хэш-кодом полученного сообщения. Если хэш-коды не совпадают, значит, сообщение было изменено.
Однако алгоритм также имеет некоторые недостатки:
•	Производительность: Алгоритм может быть медленным для больших исходных сообщений.
•	Коллизии: При определенных условиях два разных исходных сообщения могут иметь одинаковый хэш-код. Это называется коллизией. Вероятность коллизии увеличивается с увеличением размера хэш-кода.
Несмотря на эти недостатки, алгоритм является эффективным инструментом для обеспечения целостности данных.











Dim S As String - объявляет переменную типа String, которая будет хранить строку сообщения
Dim m() As Integer - объявляет массив типа Integer, который будет хранить символы строки сообщения
Dim HO, H, P, Z, K, D As Integer - объявляет ряд целочисленных переменных
Private Sub CommandButton1_Click() - определяет обработчик события Click для кнопки CommandButton1
K = 0 - инициализирует переменную K значением 0
Randomize - инициализирует генератор случайных чисел
Z = Round(1000 * Rnd()) - присваивает переменной Z случайное число в диапазоне от 0 до 999
I = 1 - инициализирует переменную I значением 1
D = 0 - инициализирует переменную D значением 0
While K <> 1 - запускает цикл While
For I = 1 To Z - цикл For, выполняющийся от 1 до Z-1
If (Z \ I) = (Z / I) Then D = D + 1 - если Z делится на I без остатка, увеличивает значение D на 1
Next I - конец цикла For
If D = 2 Then K = 1: GoTo 1 - если значение D стало равным 2, присваивает K значение 1 и переходит к метке 1, иначе уменьшает значение Z на 1 и сбрасывает значения K и D
Else Z = Z - 1: K = 0: D = 0
Wend - конец цикла While
1: HO = Z - присваивает переменной HO значение Z
TextBox2.Text = HO - отображает значение переменной HO в текстовом поле TextBox2
K = 0 - инициализирует переменную K значением 0
Randomize - инициализирует генератор случайных чисел
Z = Round(1000 * Rnd()) - присваивает переменной Z случайное число в диапазоне от 0 до 999
I = 1 - инициализирует переменную I значением 1
D = 0 - инициализирует переменную D значением 0
While K <> 1 - запускает цикл While
For I = 1 To Z - цикл For, выполняющийся от 1 до Z
If (Z \ I) = (Z / I) - если Z делится на I без остатка, увеличивает значение D на 1
Next I - конец цикла For
If D = 2 Then K = 1: GoTo 2 - если значение D стало равным 2, присваивает K значение 1 и переходит к метке 2, иначе уменьшает значение Z на 1 и сбрасывает значения K и D
Else Z = Z - 1: K = 0: D = 0
End While - конец цикла While
2: P = Z - присваивает переменной P значение Z
TextBox3.Text = P - отображает значение переменной P в текстовом поле TextBox3
TextBox4.Text = "" - очищает текстовое поле TextBox4
End Sub - конец обработчика события Click для кнопки CommandButton1
Private Sub CommandButton2_Click() - определяет обработчик события Click для кнопки CommandButton2
S = TextBox1.Text - присваивает переменной S текст из текстового поля TextBox1
HO = Val(TextBox2.Text) - преобразует текст из текстового поля TextBox2 в целое число и присваивает полученное значение переменной HO
P = Val(TextBox3.Text) - преобразует текст из текстового поля TextBox3 в целое число и присваивает полученное значение переменной P
If S = "" Then - если текст в текстовом поле TextBox1 пуст
MsgBox ("Задана пустая строка сообщения") - выводит сообщение об ошибке
End If - конец If
If HO = 0 Then - если значение переменной HO равно 0
MsgBox ("Не задан начальнай хэш") - выводит сообщение об ошибке
End If - конец If
If P = 0 Then - если значение переменной P равно 0
MsgBox ("Не задан хэш модуль") - выводит сообщение об ошибке
End If - конец If
For I = 1 To Len(S) - цикл For, выполняющийся от 1 до длины строки S
ReDim m(I) - переиндексирует массив m до размера I
m(I) = Val(Mid(S, I, 1)) - присваивает элементу массива m(I) значение символа из строки S с индексом I
Next I - конец цикла For
For I = 1 To Len(S) - цикл For, выполняющийся от 1 до длины строки S
H = ((m
Private Sub CommandButton2_Click()

S = TextBox1.Text - присваивает переменной S текст из текстового поля TextBox1
HO = Val(TextBox2.Text) - преобразует текст из текстового поля TextBox2 в целое число и присваивает полученное значение переменной HO
P = Val(TextBox3.Text) - преобразует текст из текстового поля TextBox3 в целое число и присваивает полученное значение переменной P

If S = "" Then - если текст в текстовом поле TextBox1 пуст
MsgBox ("Задана пустая строка сообщения") - выводит сообщение об ошибке
End If - конец If

If HO = 0 Then - если значение переменной HO равно 0
MsgBox ("Не задан начальнай хэш") - выводит сообщение об ошибке
End If - конец If

If P = 0 Then - если значение переменной P равно 0
MsgBox ("Не задан хэш модуль") - выводит сообщение об ошибке
End If - конец If

For I = 1 To Len(S) - цикл For, выполняющийся от 1 до длины строки S

ReDim m(I) - переиндексирует массив m до размера I

m(I) = Val(Mid(S, I, 1)) - присваивает элементу массива m(I) значение символа из строки S с индексом I

Next I - конец цикла For

For I = 1 To Len(S) - цикл For, выполняющийся от 1 до длины строки S

H = ((m(I) + HO) ^ 2) Mod P - вычисляет новый хэш-сумма, по формуле:

H = ((символ + начальный хэш)^2) mod модуль
HO = H - присваивает переменной HO новое значение хэш-суммы

Next - конец цикла For

TextBox4.Text = H - отображает значение переменной H в текстовом поле TextBox4

End Sub - конец обработчика события Click для кнопки CommandButton2

Private Sub CommandButton3_Click()

UserForm1.Hide - скрывает форму UserForm1

TextBox1.Text = "" - очищает текстовое поле TextBox1

TextBox2.Text = "" - очищает текстовое поле TextBox2

TextBox3.Text = "" - очищает текстовое поле TextBox3

TextBox4.Text = "" - очищает текстовое поле TextBox4

End Sub - конец обработчика события Click для кнопки CommandButton3

Обобщение

Эта программа реализует схему хэширования MD5. Вначале она генерирует два случайных числа: начальный хэш и модуль. Затем пользователь вводит строку сообщения. Программа проверяет, не пусты ли текстовые поля для строки сообщения, начального хэша и модуля. Если они пусты, программа выводит сообщение об ошибке.

Если все текстовые поля заполнены, программа преобразует строку сообщения в массив символов. Затем она выполняет цикл, в котором для каждого символа строки сообщения рассчитывается новый хэш-сумма по формуле (символ + начальный хэш)^2 mod модуль. В конце цикла новый хэш-сумма присваивается переменной HO.

Наконец, программа отображает значение переменной HO в текстовом поле.
